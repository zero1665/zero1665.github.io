<h1 id="openjdk--hashset">OpenJDK 源代码阅读之 HashSet</h1>

<hr />

<h2 id="section">概要</h2>

<ul>
  <li>类继承关系</li>
</ul>

<p><code>
java.lang.Object
    java.util.AbstractCollection&lt;E&gt;
        java.util.AbstractSet&lt;E&gt;
            java.util.HashSet&lt;E&gt;
</code></p>

<ul>
  <li>定义</li>
</ul>

<p><code>
public class HashSet&lt;E&gt;
extends AbstractSet&lt;E&gt;
implements Set&lt;E&gt;, Cloneable, Serializable
</code></p>

<ul>
  <li>要点</li>
</ul>

<ol>
  <li>不保证元素次序，甚至不保证次序不随时间变化</li>
  <li>基本操作(add, remove, contains, size)常量时间</li>
  <li>迭代操作与当前元素个数加底层容量大小成正比</li>
  <li>不保证同步</li>
</ol>

<h2 id="section-1">思考</h2>

<ul>
  <li>总体实现</li>
</ul>

<p>底层是用 <code>HashMap</code> 实现的，<code>Set</code> 中的数据是 <code>HashMap</code> 的 <code>key</code>，所有的 <code>key</code> 指向同一个 <code>value</code>, 此 <code>value</code> 定义为：</p>

<p><code>java
// Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
</code></p>

<p>再看一下 <code>add</code>，大概就能明白了</p>

<p><code>java
/**
 * Adds the specified element to this set if it is not already present.
 * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if
 * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that
 * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.
 * If this set already contains the element, the call leaves the set
 * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.
 *
 * @param e element to be added to this set
 * @return &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified
 * element
 */
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
</code></p>

<ul>
  <li>load factor</li>
</ul>

<p><code>java
    public HashSet(Collection&lt;? extends E&gt; c) {
        map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }
</code></p>

<p>初始化中，注意使用的 <code>HashMap</code> 的 load factor 设置为 0.75，如果太小，就设置成 16. 为什么要 0.75 呢？ 有什么依据吗？</p>

<p><code>HashSet</code> 并没有什么特别之处，几乎没有自己特有的实现，都是调用 <code>HashMap</code> 的方法实现相应的功能。</p>
