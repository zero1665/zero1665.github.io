<h1 id="section">分模块测试</h1>

<h2 id="applicationpy">application.py</h2>

<p>对 application.py 的测试，调用命令：</p>

<pre><code>python test/application.py
</code></pre>

<h3 id="testredirect">testRedirect</h3>

<p>```python
def testRedirect(self):
    urls = (
        “/a”, “redirect /hello/”,
        “/b/(.<em>)”, r”redirect /hello/\1”,
        “/hello/(.</em>)”, “hello”
    )
    app = web.application(urls, locals())
    class hello:
        def GET(self, name): 
            name = name or ‘world’
            return “hello “ + name</p>

<pre><code>response = app.request('/a')
self.assertEquals(response.status, '301 Moved Permanently')
self.assertEquals(
    response.headers['Location'], 
    'http://0.0.0.0:8080/hello/')

response = app.request('/a?x=2')
self.assertEquals(response.status, '301 Moved Permanently')
self.assertEquals(
    response.headers['Location'], 
    'http://0.0.0.0:8080/hello/?x=2')

response = app.request('/b/foo?x=2')
self.assertEquals(response.status, '301 Moved Permanently')
self.assertEquals(
    response.headers['Location'], 
    'http://0.0.0.0:8080/hello/foo?x=2') ```
</code></pre>

<p>看到这段代码首先对 <code>urls</code> 挺好奇的，<code>urls</code> 一般是一个 <code>url</code> 对应
一个处理它的类，可是 <code>redirect /hello/</code> 是什么意思？所以，我们
有必要看一下 <code>web.application</code> 如何对 <code>urls</code> 进行处理。</p>

<p>我们还从这句开始：</p>

<p><code>python
response = app.request('/a')
</code></p>

<p>看看 <code>urls</code> 是如何被处理的。</p>

<p>```python
# web.application.request</p>

<p>def request(self, localpart=’/’, method=’GET’, data=None,
            host=”0.0.0.0:8080”, headers=None, https=False, **kw):</p>

<pre><code>path, maybe_query = urllib.splitquery(localpart)
query = maybe_query or ""

...

env = dict(env, HTTP_HOST=host, REQUEST_METHOD=method, PATH_INFO=path, 
    QUERY_STRING=query, HTTPS=str(https))

...

response.data = "".join(self.wsgifunc()(env, start_response))
</code></pre>

<p>```</p>

<p>可以看出，请求的 <code>url</code> 被分成两部分： <code>path</code> 和 <code>maybe_query</code>, 
然后传入 <code>env</code>中。</p>

<p><code>urllib</code> 是标准库的一部分，但是在文档中没有对 <code>splitquery</code>
有说明，这可能是一个非公开的API。通过</p>

<pre><code>&gt;&gt;&gt; help(urllib.splitquery)
</code></pre>

<p>可以得到</p>

<pre><code>splitquery('/path?query') --&gt; '/path', 'query'
</code></pre>

<p>看来这个调用是把 <code>url</code> 请求分成路径与请求两个部分，这也和
返回结果的赋值保持一致。</p>

<p>另外，最好不要使用这个函数，python 2.7 中提供了 <code>urlparse</code>
模块，可以完成同样功能（甚至更多），python 3 中这个模块
更改为 <code>urllib.parse</code>。</p>

<p>这里不再多说，只是明白这一句是要做什么就好。我们继续看数据
封装在 <code>env</code> 后发生的故事。</p>

<p>我们又来到这里：</p>

<p><code>python
    response.data = "".join(self.wsgifunc()(env, start_response))
</code></p>

<p>最终对 <code>env</code> 的处理在 <code>wsgi</code> 函数中。</p>

<p>```python
# web.application.wsgifunc.wsgi</p>

<pre><code>    def wsgi(env, start_resp):
        # clear threadlocal to avoid inteference of previous requests
        self._cleanup()

        self.load(env)
        try:
            # allow uppercase methods only
            if web.ctx.method.upper() != web.ctx.method:
                raise web.nomethod()

            result = self.handle_with_processors()
            if is_generator(result):
                result = peep(result)
            else:
                result = [result]
        except web.HTTPError, e:
            result = [e.data]


        result = web.safestr(iter(result))

        status, headers = web.ctx.status, web.ctx.headers

        start_resp(status, headers) ```
</code></pre>

<p>同样，先把 <code>env</code> 载入 <code>web.ctx</code>， 然后我们通过 <code>print</code> 定位到
这一句改变了 <code>web.ctx.status</code> 的值。 </p>

<p><code>
                result = self.handle_with_processors()
</code></p>

<p>可见这里对 <code>url</code> 进行了分析。下面我们深入下去。</p>

<p>```python
# web.application.handle_with_processors</p>

<p>def handle_with_processors(self):
    def process(processors):
        try:
            if processors:
                p, processors = processors[0], processors[1:]
                return p(lambda: process(processors))
            else:
                return self.handle()
        except web.HTTPError:
            raise
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            print » web.debug, traceback.format_exc()
            raise self.internalerror()</p>

<pre><code># processors must be applied in the resvere order. (??)
return process(self.processors) ```
</code></pre>

<p>这里 <code>processors</code> 为空，所以进入 <code>self.handle()</code></p>

<p>```python
# web.application.handle</p>

<p>def handle(self):
    fn, args = self._match(self.mapping, web.ctx.path)
    return self._delegate(fn, self.fvars, args)
```</p>

<p>这个 <code>self.mapping</code> 是将我们的 <code>urls</code> 转化成两两一组后的列表。
先看看 <code>_match</code>函数。</p>

<p>```python
# web.application._match</p>

<p>def _match(self, mapping, value):
    for pat, what in mapping:
        if isinstance(what, application):
            if value.startswith(pat):
                f = lambda: self._delegate_sub_application(pat, what)
                return f, None
            else:
                continue
        elif isinstance(what, basestring):
            what, result = utils.re_subm(‘^’ + pat + ‘$’, what, value)
        else:
            result = utils.re_compile(‘^’ + pat + ‘$’).match(value)</p>

<pre><code>    if result: # it''s a match
        return what, [x for x in result.groups()]
return None, None ```
</code></pre>

<p>可以看出这是一个循环，根据当前的 <code>value</code> ，即 <code>web.ctx.path</code>
去查找 <code>urls</code> 中定义的对应项。what就是这个项。
先使用 <code>isinstance(what, application)</code> 看是不是使用了子程序。
再看看what是不是 <code>basestring</code> 的实例。直到运行至
result不为空，这说明找到了一个匹配。然后会返回匹配中
的所有分组。</p>

<p>当前的运行会选择第二个分支。
即：</p>

<p>```python
# web.application._match</p>

<p>elif isinstance(what, basestring):
    what, result = utils.re_subm(‘^’ + pat + ‘$’, what, value)
```</p>

<p><code>utils.re_subm</code> 对路径中的正则表达式进行处理。<code>pat</code> 和 <code>what</code>
是 <code>urls</code> 中对应的项， <code>value</code> 是当前的请求路径。</p>

<p>```python
# utils.re_subm</p>

<p>def re_subm(pat, repl, string):
    “””
    Like re.sub, but returns the replacement <em>and</em> the match object.</p>

<pre><code>    &gt;&gt;&gt; t, m = re_subm('g(oo+)fball', r'f\\1lish', 'goooooofball')
    &gt;&gt;&gt; t
    'foooooolish'
    &gt;&gt;&gt; m.groups()
    ('oooooo',)
"""
compiled_pat = re_compile(pat)
proxy = _re_subm_proxy()
compiled_pat.sub(proxy.__call__, string)
return compiled_pat.sub(repl, string), proxy.match
</code></pre>

<p>```</p>

<p>这里 <code>re_compile(pat)</code> 的含义与 <code>re.complie(pat)</code> 类似，
返回一个<code>RegexObject</code> 对象，只不过加入了 <code>Cache</code> 机制，避免多次执行 <code>re.complie</code> 调用。</p>

<p>下面看这两行代码</p>

<p><code>python
proxy = _re_subm_proxy()
compiled_pat.sub(proxy.__call__, string)
</code></p>

<p>其中 <code>_re_subm_proxy</code> 定义为：</p>

<p><code>python
class _re_subm_proxy:
    def __init__(self): 
        self.match = None
    def __call__(self, match): 
        self.match = match
        return ''
</code></p>

<p><code>compiled_pat</code> 会与 <code>string</code> 一起生成一个 <code>Match</code> 对象，
这个对象会存储在一个 <code>_re_subm_proxy</code> 对象，即 <code>proxy</code>中
我们可以看到 <code>return</code> 中，<code>proxy</code> 最后会将其 <code>match</code> 返回。
我在想，为什么使用<code>search</code>直接生成一个 <code>Match</code>  对象然后返回呢？
查了一下，这似乎与 <code>代理模式</code> 相关。但具体为什么还不知道。又查了很久，似乎又与 <code>弱引用</code>, 和之前的 Cache 相关,
但是不确定。</p>

<pre><code>问题：为什么要使用代理类
</code></pre>

<p>最后的 <code>return</code> 语句返回两个值，其中
<code>compiled_pat.sub (repl, string)</code> 是把 <code>string</code> 与 <code>pat</code>
中匹配的部分，用于替换 <code>repl</code> 中对应的组号。<code>proxy.match</code> 就是 <code>pat</code> 和 <code>string</code> 匹配得到的　<code>Mathc</code>对象。</p>

<p>关于 <code>Python 正则表达式</code> 可以参考这篇：
<a href="http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html">Python 正则表达式指南</a></p>

<p>到这里，我们可能就明白了一开始的时候的那段：</p>

<p>```python
# web.application._match</p>

<p>elif isinstance(what, basestring):
    what, result = utils.re_subm(‘^’ + pat + ‘$’, what, value)
```</p>

<p>的含义，它的意思是如何 <code>urls</code> 里有一对 <code>(url,class)</code>
其中 <code>url</code> 和　<code>class</code> 都是用正则表达式表示的，
这时候实际来了一个请求 <code>r_url</code>，它会与 <code>url</code>进行
匹配，根据这个匹配生成相应的 <code>r_class</code>。</p>

<p>看看刚才的示例就明白了：</p>

<pre><code>&gt;&gt;&gt; t, m = re_subm('g(oo+)fball', r'f\\1lish', 'goooooofball')
&gt;&gt;&gt; t
'foooooolish'
</code></pre>

<p>你可以把 <code>re_subm</code> 的三个参数依序当成 <code>url</code>, <code>class</code>，
以及 <code>r_url</code>，最后得到的 <code>t</code> 就是 <code>r_class</code>。</p>

<p>举个例子，假如有一系列页面，分别是 <code>req1</code>, <code>req2</code>, 
<code>req3</code>, … , <code>reqN</code>, 需要处理。</p>

<p>那么就可以在 <code>urls</code> 里加入</p>

<pre><code>(r'req(\d+)', r'proc\1')
</code></pre>

<p>这样，如果来了请求　<code>req2</code>，通过<code>re_subm</code>自然会解析成 <code>proc2</code>。</p>

<pre><code>&gt;&gt;&gt; t, m = re_subm(r'req(\d+)', r'proc\1', 'req2')
&gt;&gt;&gt; t
'proc2'
&gt;&gt;&gt; m.group(0)
'req2'
&gt;&gt;&gt; m.group(1)
'2'
</code></pre>

<p>总之，</p>

<p><code>python
def handle(self):
    fn, args = self._match(self.mapping, web.ctx.path)
    return self._delegate(fn, self.fvars, args)
</code></p>

<p><code>self._match</code> 返回的是请求 <code>request('/a')</code> 与</p>

<p><code>
python
        urls = (
            "/a", "redirect /hello/",
            "/b/(.*)", r"redirect /hello/\1",
            "/hello/(.*)", "hello"
        )
</code></p>

<p>进行匹配后的结果， <code>'/a'</code> 自然与 <code>urls[0]</code>
匹配，得到的 <code>fn</code> 是 <code>"redirect /hello/"</code>,
得到的 <code>args</code> 是 <code>[]</code>，因为<code>urls[0]</code>里面就没分组。</p>

<p>好了，现在进入 <code>self._delegate</code>，看看解析后的
<code>fn</code> 和　<code>args</code> 被如何处理。</p>

<p>```python
def _delegate(self, f, fvars, args=[]):
    def handle_class(cls):
        meth = web.ctx.method
        if meth == ‘HEAD’ and not hasattr(cls, meth):
            meth = ‘GET’
        if not hasattr(cls, meth):
            raise web.nomethod(cls)
        tocall = getattr(cls(), meth)
        return tocall(*args)</p>

<pre><code>def is_class(o): return isinstance(o, (types.ClassType, type))
    
if f is None:
    raise web.notfound()
elif isinstance(f, application):
    return f.handle_with_processors()
elif is_class(f):
    return handle_class(f)
elif isinstance(f, basestring):
    if f.startswith('redirect '):
        url = f.split(' ', 1)[1]
        if web.ctx.method == "GET":
            x = web.ctx.env.get('QUERY_STRING', '')
            if x:
                url += '?' + x
        raise web.redirect(url)
    elif '.' in f:
        mod, cls = f.rsplit('.', 1)
        mod = __import__(mod, None, None, [''])
        cls = getattr(mod, cls)
    else:
        cls = fvars[f]
    return handle_class(cls)
elif hasattr(f, '__call__'):
    return f()
else:
    return web.notfound() ```
</code></pre>

<p>一眼就可以看出有一个 <code>elif</code> 分支对 <code>redirect</code> 进行了处理。</p>

<p><code>python
elif isinstance(f, basestring):
    if f.startswith('redirect '):
        url = f.split(' ', 1)[1]
        if web.ctx.method == "GET":
            x = web.ctx.env.get('QUERY_STRING', '')
            if x:
                url += '?' + x
        raise web.redirect(url)
</code></p>

<p>分析出 <code>redirect /hello/</code> 中的 <code>/hello/</code>，再看看
有没有查询字串，就是请求里有没有<code>?xx</code> 什么的。
得到最终的 <code>url</code> ，转给 <code>redirect</code> 函数处理。
直接找到 <code>webapi.py</code>，看到 <code>redirect</code> 的定义。</p>

<p>```python
class Redirect(HTTPError):
    “"”A <code>301 Moved Permanently</code> redirect.”””
    def <strong>init</strong>(self, url, status=’301 Moved Permanently’, absolute=False):
        “””
        Returns a <code>status</code> redirect to the new URL. 
        <code>url</code> is joined with the base URL so that things like 
        `redirect(“about”) will work properly.
        “””
        newloc = urlparse.urljoin(ctx.path, url)</p>

<pre><code>    if newloc.startswith('/'):
        if absolute:
            home = ctx.realhome
        else:
            home = ctx.home
        newloc = home + newloc

    headers = {
        'Content-Type': 'text/html',
        'Location': newloc
    }
    HTTPError.__init__(self, status, headers, "")
</code></pre>

<p>redirect = Redirect
```</p>

<p>这时候传过来的 <code>url</code> 是 <code>/hello/</code>。 注意 <code>status</code>
的默认值。
先使用 <code>urljoin</code> 得到一个绝对路径。官网上给出的
<code>urlparse.urljoin</code> 的例子是：</p>

<p><code>python
&gt;&gt;&gt; from urlparse import urljoin
&gt;&gt;&gt; urljoin('http://www.cwi.nl/%7Eguido/Python.html', 'FAQ.html')
'http://www.cwi.nl/%7Eguido/FAQ.html'
</code></p>

<p>另外一个例子是针对第二个参数是绝对路径的情况的。</p>

<p><code>python
&gt;&gt;&gt; urljoin('http://www.cwi.nl/%7Eguido/Python.html',
...         '//www.python.org/%7Eguido')
'http://www.python.org/%7Eguido'
</code></p>

<p>第二个例子的用法和我们当前的状况一致。所以得到的
<code>newloc</code> 还是 <code>/hello/</code>。</p>

<p>然后再查看 <code>ctx.home</code> 和 <code>ctx.realhome</code> 得到
新的　<code>newloc</code>。</p>

<p>在 <code>application.py</code> 中， <code>load</code> 函数定义了一些 <code>path</code>:</p>

<p><code>python
ctx.homedomain = ctx.protocol + '://' + env.get('HTTP_HOST', '[unknown]')
ctx.homepath = os.environ.get('REAL_SCRIPT_NAME', env.get('SCRIPT_NAME', ''))
ctx.home = ctx.homedomain + ctx.homepath
#@@ home is changed when the request is handled to a sub-application.
#@@ but the real home is required for doing absolute redirects.
ctx.realhome = ctx.home
</code></p>

<p>从这可以看出，如果调用子程序　<code>ctx.home</code> 会改变，
但是　<code>ctx.realhome</code> 不会变，它用来在 redirect 时
生成绝对路径。</p>

<p><code>python
if newloc.startswith('/'):
    if absolute:
        home = ctx.realhome
    else:
        home = ctx.home
    newloc = home + newloc
</code></p>

<p>现在可以理解了，如果 <code>absolute</code> 为真，那就用
<code>ctx.realhome</code> 和 <code>newloc</code> 组成新值，
如果不为真，直接用 <code>ctx.home</code>。这可能在使用子程序，
可以转向到以子程序为基础的<code>url</code> 中。</p>

<p>现在回到 <code>Redirect</code>。转到 <code>HTTPError</code>。</p>

<p><code>python
class HTTPError(Exception):
    def __init__(self, status, headers={}, data=""):
        ctx.status = status
        for k, v in headers.items():
            header(k, v)
        self.data = data
        Exception.__init__(self, status)
</code></p>

<p><code>ctx.status</code> 被设置，调用 <code>Exception</code>。</p>

<p>之后我们回到　<code>web.redirect(status)</code> 调用处。</p>

<p>```python
def _delegate(self, f, fvars, args=[]):</p>

<pre><code>...

elif isinstance(f, basestring):
    if f.startswith('redirect '):
        url = f.split(' ', 1)[1]
        if web.ctx.method == "GET":
            x = web.ctx.env.get('QUERY_STRING', '')
            if x:
                url += '?' + x
        raise web.redirect(url)


...
</code></pre>

<p>```</p>

<p>可以看出，这里把异常抛出。所以我们回到上一层，看看
相应的处理。</p>

<p>上一层：</p>

<p><code>python
def handle(self):
    fn, args = self._match(self.mapping, web.ctx.path)
    return self._delegate(fn, self.fvars, args)
</code></p>

<p>再上一层：</p>

<p>```python
# web.application.handle_with_processors</p>

<p>def handle_with_processors(self):
    def process(processors):
        try:
            if processors:
                p, processors = processors[0], processors[1:]
                return p(lambda: process(processors))
            else:
                return self.handle()
        except web.HTTPError:
            raise
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            print » web.debug, traceback.format_exc()
            raise self.internalerror()</p>

<pre><code># processors must be applied in the resvere order. (??)
return process(self.processors) ```
</code></pre>

<p>再上一层：</p>

<p>```python
# web.application.wsgifunc.wsgi</p>

<pre><code>    def wsgi(env, start_resp):
        # clear threadlocal to avoid inteference of previous requests
        self._cleanup()

        self.load(env)
        try:
            # allow uppercase methods only
            if web.ctx.method.upper() != web.ctx.method:
                raise web.nomethod()

            result = self.handle_with_processors()
            if is_generator(result):
                result = peep(result)
            else:
                result = [result]
        except web.HTTPError, e:
            result = [e.data]


        result = web.safestr(iter(result))

        status, headers = web.ctx.status, web.ctx.headers

        start_resp(status, headers) ```
</code></pre>

<p>这里终于看到了对异常的处理。这里 <code>e.data</code> 为空。我
们之前并没有设置这个值。</p>

<p>接着看后续处理, <code>safestr</code> 在 <code>utils.py</code> 中定义，
它负责把给定的对象转化成 <code>utf-8</code> 编码的字符串。
下一句设置 <code>status</code> 和 <code>headers</code> 的值。之前</p>

<p>我们已经看到 <code>web.ctx.status</code> 被设置了:</p>

<p><code>python
class HTTPError(Exception):
    def __init__(self, status, headers={}, data=""):
        ctx.status = status
        for k, v in headers.items():
            header(k, v)
        self.data = data
        Exception.__init__(self, status)
</code></p>

<p><code>__init__</code> 中的 <code>status</code> 参数在上一层中设置。</p>

<p>```python
class Redirect(HTTPError):
    “"”A <code>301 Moved Permanently</code> redirect.”””
    def <strong>init</strong>(self, url, status=’301 Moved Permanently’, absolute=False):
        “””
        Returns a <code>status</code> redirect to the new URL. 
        <code>url</code> is joined with the base URL so that things like 
        `redirect(“about”) will work properly.
        “””
        newloc = urlparse.urljoin(ctx.path, url)</p>

<pre><code>    if newloc.startswith('/'):
        if absolute:
            home = ctx.realhome
        else:
            home = ctx.home
        newloc = home + newloc

    headers = {
        'Content-Type': 'text/html',
        'Location': newloc
    }
    HTTPError.__init__(self, status, headers, "")
</code></pre>

<p>redirect = Redirect
```</p>

<p>注意这里的　<code>status</code> 默认参数。</p>

<p>现在再回到 </p>

<p>```python
def wsgi(env, start_resp):
    # clear threadlocal to avoid inteference of previous requests
    self._cleanup()</p>

<pre><code>self.load(env)

try:
    # allow uppercase methods only
    if web.ctx.method.upper() != web.ctx.method:
        raise web.nomethod()


    result = self.handle_with_processors()

    if is_generator(result):
        result = peep(result)
    else:
        result = [result]
except web.HTTPError, e:
    result = [e.data]


result = web.safestr(iter(result))

status, headers = web.ctx.status, web.ctx.headers

start_resp(status, headers)

def cleanup():
    self._cleanup()
    yield '' # force this function to be a generator

return itertools.chain(result, cleanup()) ```
</code></pre>

<p>随后调用　<code>start_resp</code> ，对 <code>status</code>, <code>headers</code>
进行处理。我们再回到上一层。</p>

<p>```python
#web.application.request</p>

<p>def request(self, localpart=’/’, method=’GET’, data=None,
                host=”0.0.0.0:8080”, headers=None, https=False, **kw):</p>

<pre><code>    ...

    response = web.storage()
    def start_response(status, headers):
        response.status = status
        response.headers = dict(headers)
        response.header_items = headers
    response.data = "".join(self.wsgifunc()(env, start_response))
    return response ```
</code></pre>

<p>这时候，<code>response</code> 中的 <code>stauts</code>　会设置好。
最后，返回最初的调用。</p>

<p>```python
def testRedirect(self):
    urls = (
        “/a”, “redirect /hello/”,
        “/b/(.<em>)”, r”redirect /hello/\1”,
        “/hello/(.</em>)”, “hello”
    )
    app = web.application(urls, locals())
    class hello:
        def GET(self, name): 
            name = name or ‘world’
            return “hello “ + name</p>

<pre><code>response = app.request('/a')
self.assertEquals(response.status, '301 Moved Permanently')
self.assertEquals(response.headers['Location'], 'http://0.0.0.0:8080/hello/') ```
</code></pre>

<p><code>self.assertEquals</code> 会验证 <code>response.status</code> 的值。</p>

<p>所以，到这里，<code>testRedirect</code> 函数就分析结束了。</p>
