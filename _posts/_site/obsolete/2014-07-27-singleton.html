<h1 id="section">单例模式</h1>

<hr />

<ul>
  <li>定义 </li>
</ul>

<p>单例模式确保一个类只有一个实例，并提供一个全局访问点</p>

<ul>
  <li>解释</li>
</ul>

<p>从定义可以看出，特点是这个类只有一个实例。那么，为什么要这么做呢？原因在于，有些时候，这个类只有一个实例会节约资源，或者只有一个实例才能保证整个程序运行正确，一致。例如：线程池，缓存，对话框，日志对象等等 。</p>

<ul>
  <li>示例</li>
</ul>

<p>```java
class Singleton {
	private static Singleton singleton;</p>

<pre><code>private Singleton() {
}

public static Singleton getInstance() {
	if (singleton == null) {
		singleton = new Singleton();
	}
	return singleton;
} } ```
</code></pre>

<p>这是单例的经典使用方式：</p>

<ul>
  <li>一个 private static 对象</li>
  <li>构造器设置为 private</li>
  <li>一个 public static 方法提供全局访问点 </li>
</ul>

<p>开始的时候，其实我比较困惑为什么不在 singleton 声明处直接实例化对象，后来明白了，这是一种延迟实例化的手段，保证只在需要时才实例化。如果直接在声明时实例化，那么只要类加载了，即使不需要对象，也会对它进行实例化。</p>

<p>另外，这个经典使用方式其实是有问题的，对比后面 Tomcat 中的应用场景，你可能会发现问题所在。</p>

<p>在 Tomcat 中，就有一个单例模式，它是 <code>org.apache.catalina.tribes.util.StringManager</code> 类。在 Tomcat 中，会有许多地方需要对错误消息进行处理。我们使用 <code>StringManager</code> 类来管理这些错误消息。</p>

<p>错误消息首先不能硬编码到代码中，否则需要提供国际化支持时，就会很痛苦。错误消息需要定义在配置文件中。Tomcat 为每个包 (package) 都提供了三种语言的错误消息配置文件。每个包内都有很多类，我们没必要为每个类都生成一个 <code>StringManager</code> 类，因为它们共享同一个配置文件。所以，一个包只需要一个 <code>StringManager</code> 对象就好了。我们怎么为一个包生成一个 <code>StringManager</code> 呢？ Tomcat 在 <code>StringManager</code> 内部保存着所有包的 <code>StringManager</code> 实例，你需要一个实例时，只需要提供包名，调用 <code>StringManager</code> 的相应方法，就会返回与此包名对应的 <code>StringManager</code> 实例。下面是相关的代码，一目了然。</p>

<p>```java</p>

<p>public class StringManager { </p>

<p>private StringManager(String packageName) {
    …
}</p>

<p>private static final Hashtable&lt;String, StringManager&gt; managers =
new Hashtable&lt;&gt;();</p>

<p>/**
* Get the StringManager for a particular package. If a manager for
* a package already exists, it will be reused, else a new
* StringManager will be created and returned.
*
* @param packageName The package name
*/
public static final synchronized StringManager getManager(String packageName) {
    StringManager mgr = managers.get(packageName);
    if (mgr == null) {
        mgr = new StringManager(packageName);
        managers.put(packageName, mgr);
    }
    return mgr;
}
```</p>

<p>使用了一个 <code>Hashtable</code> 来保存 <code>managers</code>，每次通过 <code>getManager</code> 方法，通过包名访问，如果访问不到，就为此包新生成一个 <code>StringManager</code> 实例。</p>

<p>有没有注意到 getManager 方法被  <code>synchronized</code> 修饰？这就是之前我们举的经典示例时说的问题。在使用单例时，只有一个对象，这个对象可能是被多个线程共享的。如果不同步，就可能会出现数据不一致的情况。例如，两个线程同时调用了 <code>getManager</code>，访问同一个包名。正确的执行是，其中一个线程第一次调用时，mgr 为空，此时生成一个 StringManager。第二个线程调用时，mgr 就不为空了。但是，如果不同步，那么当第一个线程通过了 <code>if(mgr == null)</code> 时，此时线程被切换了，这时，第二个线程也会通过 <code>if(mgr == null)</code> ，这样就导致同一个包，生成了两个 <code>StringManager</code>。</p>

<ul>
  <li>扩展阅读 </li>
</ul>

<p>关于单例模式与线程安全，建议阅读一下这篇文章：</p>

<p><a href="http://blog.csdn.net/haoel/article/details/4028232">深入浅出单实例Singleton设计模式</a></p>

<p>关于单例模式的其它实现方式，可以阅读 </p>

<p><a href="http://cantellow.iteye.com/blog/838473">单例模式的七种写法</a></p>
